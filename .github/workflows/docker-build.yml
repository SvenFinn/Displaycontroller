#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches:
      - "development"
  create:
  workflow_dispatch:
    inputs:
      version:
        description: "Version to tag the Docker image with"
        required: true
        default: "development"

permissions:
  contents: read
  packages: write

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  prep-args:
    runs-on: ubuntu-latest
    #outputs:
    #  args: ${{ steps.services.outputs.args }}

    steps:
      - name: Checkout the repository
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install yq jq -y

      # Determine APP_VERSION
      - name: Determine APP_VERSION
        id: app-version
        run: |
          if [ ! -z "${{ github.event.inputs.version }}" ]; then
            app_version="${{ github.event.inputs.version }}"
          else
            branch=$(git branch --show-current)
            if [ "$branch" = "development" ]; then
              app_version="development"
            else
              app_version=$(git describe --tags --abbrev=0)
            fi
          fi
          echo "app_version=$app_version"
          echo "app_version=$app_version" >> $GITHUB_OUTPUT

  prep-matrix:
    runs-on: ubuntu-latest

    # This job is responsible for setting up the matrix of build jobs that will run in parallel.
    outputs:
      matrix: ${{ steps.services.outputs.services }}

    steps:
      - name: Checkout the repository
        uses: actions/checkout@v4

      - name: Install yq
        run: |
          sudo apt-get update
          sudo apt-get install yq jq -y

      - name: Determine services
        id: services
        run: |
          cd src
          config=$(docker compose config 2>/dev/null)
          services=$(echo "$config" | yq '.services | to_entries | map(select(.value.image | test("^ghcr\\.io"))) | .[].key')

          # Convert the service names into a properly formatted JSON array
          servicesJson=$(echo "$services" | jq -R -s -c 'split("\n") | map(select(length > 0) | gsub("^\"|\"$"; ""))')          # Output the JSON to a file (for debugging purposes) and set it in the environment
          echo "services=$servicesJson" >> $GITHUB_OUTPUT
          echo "$servicesJson"

  build:
    needs: prep-matrix
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{fromJson(needs.prep-matrix.outputs.matrix)}}

    steps:
      - name: Install yq
        run: |
          sudo apt-get update
          sudo apt-get install yq jq -y

      - name: Checkout the repository
        uses: actions/checkout@v4

      - name: Generate build config
        id: build-config
        env:
          SELF_DB_URL: ${{ vars.SELF_DB_URL }}
          SERVER_STATE_HOST: ${{ vars.SERVER_STATE_HOST }}
          MIN_MEYTON_VERSION: ${{ vars.MIN_MEYTON_VERSION }}
          MAX_MEYTON_VERSION: ${{ vars.MAX_MEYTON_VERSION }}
          MEYTON_SSH_USER: ${{ vars.MEYTON_SSH_USER }}
          MEYTON_SSH_PASS: ${{ vars.MEYTON_SSH_PASS }}
          MEYTON_DB_USER: ${{ vars.MEYTON_DB_USER }}
          MEYTON_DB_PASS: ${{ vars.MEYTON_DB_PASS }}
          DISCIPLINE_DEFAULT_COLOR: ${{ vars.DISCIPLINE_DEFAULT_COLOR }}
          MULTICAST_MSG_MIN_LENGTH: ${{ vars.MULTICAST_MSG_MIN_LENGTH }}
          LOG_LEVEL: ${{ vars.LOG_LEVEL }}
          APP_PORT: ${{ vars.APP_PORT }}
        run: |
          cd src

          config=$(docker compose config ${{ matrix.service }} 2>/dev/null | yq -r '.services."${{ matrix.service }}"')
          echo $config
          image=$(echo "$config" | jq -r -c .image)
          context=$(echo "$config" | jq -r -c .build.context)
          dockerfile=$(echo "$config" | jq -r -c .build.dockerfile)
          if [ "$(echo "$config" | jq -r -c '.build.args')" = "null" ]; then
            args='""'
          else
            args=$(echo "$config" | jq -r -c '.build.args | to_entries | map("\(.key)=\(.value)") | join("\n") | @json')
          fi
          if [ "$(echo "$config" | jq -r -c '.build.additional_contexts')" = "null" ]; then
            additional_contexts='""'
          else
            additional_contexts=$(echo "$config" | jq -r -c '.build.additional_contexts | to_entries | map("\(.key)=\(.value)") | join("\n") | @json')
          fi

          echo "image=$image"
          echo "context=$context"
          echo "dockerfile=$dockerfile"
          echo "args=$args"
          echo "additional_contexts=$additional_contexts"
          echo "image=$image" >> $GITHUB_OUTPUT
          echo "context=$context" >> $GITHUB_OUTPUT
          echo "dockerfile=$dockerfile" >> $GITHUB_OUTPUT
          echo "args=$args" >> $GITHUB_OUTPUT
          echo "additional_contexts=$additional_contexts" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: metadata
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.build-config.outputs.image }}

      - name: Build and Push the Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ steps.build-config.outputs.context }}
          file: "${{ steps.build-config.outputs.context }}/${{ steps.build-config.outputs.dockerfile }}"
          build-args: |
            ${{ fromJson(steps.build-config.outputs.args) }}
          build-contexts: |
            ${{ fromJson(steps.build-config.outputs.additional_contexts) }}
          tags: ${{ steps.metadata.outputs.tags }}
          labels: ${{ steps.metadata.outputs.labels }}
          push: true
